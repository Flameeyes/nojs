config("feature_flags") {
  defines = [
    "V8_DEPRECATION_WARNINGS"
  ]
}

config("debug") {
  defines = [
    "_DEBUG",
    "DYNAMIC_ANNOTATIONS_ENABLED=1"
  ]
}

config("release") {
  defines = [ "NDEBUG", "NVALGRIND" ]
}

config("default_libs") {
  if (is_win) {
    # TODO(brettw) this list of defaults should probably be smaller, and
    # instead the targets that use the less common ones (e.g. wininet or
    # winspool) should include those explicitly.
    libs = [
    ]
  } else if (is_android) {
    libs = [
      "dl",
      "m",
    ]
  } else if (is_mac) {
    libs = [
    ]
  } else if (is_ios) {
    # The libraries listed here will be specified for both the target and the
    # host. Only the common ones should be listed here.
    libs = [
    ]
  } else if (is_linux) {
    libs = [
      "dl",
      "rt",
    ]
  }
}

# Windows linker setup for EXEs and DLLs.
if (is_win) {
  _windows_linker_configs = [
    "//build/config/win:common_linker_setup",
  ]
}

# This config defines the configs applied to all executables.
config("executable_config") {
  configs = []

  if (is_win) {
    configs += _windows_linker_configs
  } else if (is_mac) {
    configs += [
      "//build/config/mac:mac_dynamic_flags",
      "//build/config/mac:mac_executable_flags",
    ]
  } else if (is_linux || is_android) {
    configs += [ "//build/config/gcc:executable_ldconfig" ]
  }
}

# Shared library configs -------------------------------------------------------

# This config defines the configs applied to all shared libraries.
config("shared_library_config") {
  configs = []

  if (is_win) {
    configs += _windows_linker_configs
  } else if (is_mac) {
    configs += [ "//build/config/mac:mac_dynamic_flags" ]
  }
}

# Add this config to your target to enable precompiled headers.
#
# Precompiled headers are done on a per-target basis. If you have just a couple
# of files, the time it takes to precompile (~2 seconds) can actually be longer
# than the time saved. On a Z620, a 100 file target compiles about 2 seconds
# faster with precompiled headers, with greater savings for larger targets.
#
# Recommend precompiled headers for targets with more than 50 .cc files.
config("precompiled_headers") {
  if (is_win) {
    # This is a string rather than a file GN knows about. It has to match
    # exactly what's in the /FI flag below, and what might appear in the source
    # code in quotes for an #include directive.
    precompiled_header = "build/precompile.h"

    # This is a file that GN will compile with the above header. It will be
    # implicitly added to the sources (potentially multiple times, with one
    # variant for each language used in the target).
    precompiled_source = "//build/precompile.cc"

    # Force include the header.
    cflags = [ "/FI$precompiled_header" ]

    # Disable warning for "this file was empty after preprocessing". This
    # error is generated only in C mode for ANSI compatibility. It conflicts
    # with precompiled headers since the source file that's "compiled" for
    # making the precompiled header is empty.
    #
    # This error doesn't happen every time. In VS2013, it seems if the .pch
    # file doesn't exist, no error will be generated (probably MS tested this
    # case but forgot the other one?). To reproduce this error, do a build,
    # then delete the precompile.c.obj file, then build again.
    cflags_c = [ "/wd4206" ]
  } else if (is_mac) {
    precompiled_header = "build/precompile.h"
    precompiled_source = "//build/precompile.h"
  }
}
