if (target_os == "") {
  target_os = host_os
}

if (target_cpu == "") {
  if (target_os == "android") {
    target_cpu = "arm"
  } else {
    target_cpu = host_cpu
  }
}

if (current_cpu == "") {
  current_cpu = target_cpu
}
if (current_os == "") {
  current_os = target_os
}

declare_args() {
  # Component build.
  is_component_build = false

  # Debug build.
  is_debug = true

  # Whether we're a traditional desktop unix.
  is_desktop_linux = current_os == "linux"

  # Set to true when compiling with the Clang compiler. Typically this is used
  # to configure warnings.
  is_clang = current_os == "mac" || current_os == "ios"

  # Allows the path to a custom target toolchain to be injected as a single
  # argument, and set as the default toolchain.
  custom_toolchain = ""

  # This should not normally be set as a build argument.  It's here so that
  # every toolchain can pass through the "global" value via toolchain_args().
  host_toolchain = ""

  # Enable Link Time Optimization (output programs runs faster,
  # but linking is up to 5-20x slower.
  is_lto = false

  # DON'T ADD MORE FLAGS HERE. Read the comment above.
}

if (host_toolchain == "") {
  if (host_os == "linux") {
    host_toolchain = "//build/toolchain/linux:$host_cpu"
  } else if (host_os == "mac") {
    host_toolchain = "//build/toolchain/mac:clang_$host_cpu"
  } else if (host_os == "win") {
    host_toolchain = "//build/toolchain/win:$target_cpu"
  } else {
    assert(false, "Unsupported host_os: $host_os")
  }
}

if (target_os == "linux") {
  _default_toolchain = "//build/toolchain/linux:$target_cpu"
} else if (target_os == "mac") {
  _default_toolchain = host_toolchain
} else if (target_os == "win") {
  _default_toolchain = "//build/toolchain/win:$target_cpu"
} else {
  assert(false, "Unsupported target_os: $target_os")
}

if (custom_toolchain != "") {
  set_default_toolchain(custom_toolchain)
} else if (_default_toolchain != "") {
  set_default_toolchain(_default_toolchain)
}

if (current_os == "win" || current_os == "winrt_81" ||
    current_os == "winrt_81_phone" || current_os == "winrt_10") {
  is_android = false
  is_chromeos = false
  is_ios = false
  is_linux = false
  is_mac = false
  is_nacl = false
  is_posix = false
  is_win = true
} else if (current_os == "mac") {
  is_android = false
  is_chromeos = false
  is_ios = false
  is_linux = false
  is_mac = true
  is_nacl = false
  is_posix = true
  is_win = false
} else if (current_os == "android") {
  is_android = true
  is_chromeos = false
  is_ios = false
  is_linux = false
  is_mac = false
  is_nacl = false
  is_posix = true
  is_win = false
} else if (current_os == "chromeos") {
  is_android = false
  is_chromeos = true
  is_ios = false
  is_linux = true
  is_mac = false
  is_nacl = false
  is_posix = true
  is_win = false
} else if (current_os == "nacl") {
  # current_os == "nacl" will be passed by the nacl toolchain definition.
  # It is not set by default or on the command line. We treat is as a
  # Posix variant.
  is_android = false
  is_chromeos = false
  is_ios = false
  is_linux = false
  is_mac = false
  is_nacl = true
  is_posix = true
  is_win = false
} else if (current_os == "ios") {
  is_android = false
  is_chromeos = false
  is_ios = true
  is_linux = false
  is_mac = false
  is_nacl = false
  is_posix = true
  is_win = false
} else if (current_os == "linux") {
  is_android = false
  is_chromeos = false
  is_ios = false
  is_linux = true
  is_mac = false
  is_nacl = false
  is_posix = true
  is_win = false
}

sources_assignment_filter = []
if (!is_posix) {
  sources_assignment_filter += [
    "*_posix.h",
    "*_posix.cc",
    "*_posix_unittest.h",
    "*_posix_unittest.cc",
    "*\bposix/*",
  ]
}
if (!is_win) {
  sources_assignment_filter += [
    "*_win.cc",
    "*_win.h",
    "*_win_unittest.cc",
    "*\bwin/*",
    "*.def",
    "*.rc",
  ]
}
if (!is_mac) {
  sources_assignment_filter += [
    "*_mac.h",
    "*_mac.cc",
    "*_mac.mm",
    "*_mac_unittest.h",
    "*_mac_unittest.cc",
    "*_mac_unittest.mm",
    "*\bmac/*",
    "*_cocoa.h",
    "*_cocoa.cc",
    "*_cocoa.mm",
    "*_cocoa_unittest.h",
    "*_cocoa_unittest.cc",
    "*_cocoa_unittest.mm",
    "*\bcocoa/*",
  ]
}
if (!is_ios) {
  sources_assignment_filter += [
    "*_ios.h",
    "*_ios.cc",
    "*_ios.mm",
    "*_ios_unittest.h",
    "*_ios_unittest.cc",
    "*_ios_unittest.mm",
    "*\bios/*",
  ]
}
if (!is_mac && !is_ios) {
  sources_assignment_filter += [ "*.mm" ]
}
if (!is_linux) {
  sources_assignment_filter += [
    "*_linux.h",
    "*_linux.cc",
    "*_linux_unittest.h",
    "*_linux_unittest.cc",
    "*\blinux/*",
  ]
}
if (!is_android) {
  sources_assignment_filter += [
    "*_android.h",
    "*_android.cc",
    "*_android_unittest.h",
    "*_android_unittest.cc",
    "*\bandroid/*",
  ]
}
if (!is_chromeos) {
  sources_assignment_filter += [
    "*_chromeos.h",
    "*_chromeos.cc",
    "*_chromeos_unittest.h",
    "*_chromeos_unittest.cc",
    "*\bchromeos/*",
  ]
}
set_sources_assignment_filter(sources_assignment_filter)

# =============================================================================
# TARGET DEFAULTS
# =============================================================================
#
# Set up the default configuration for every build target of the given type.
# The values configured here will be automatically set on the scope of the
# corresponding target. Target definitions can add or remove to the settings
# here as needed.

# Holds all configs used for making native executables and libraries, to avoid
# duplication in each target below.
_native_compiler_configs = [
  "//build/config:feature_flags",
  "//build/config/compiler:compiler",
  "//build/config/compiler:clang_stackrealign",
  "//build/config/compiler:compiler_arm_fpu",
  "//build/config/compiler:chromium_code",
  "//build/config/compiler:default_include_dirs",
  "//build/config/compiler:default_optimization",
  "//build/config/compiler:default_symbols",
  "//build/config/compiler:no_rtti",
  "//build/config/compiler:runtime_library",
]
if (is_win) {
  _native_compiler_configs += [
    "//build/config/win:lean_and_mean",
    "//build/config/win:nominmax",
    "//build/config/win:unicode",
    "//build/config/win:winver",
    "//build/config/win:vs_code_analysis",
  ]
}
if (is_posix) {
  _native_compiler_configs += [
    "//build/config/gcc:no_exceptions",
    "//build/config/gcc:symbol_visibility_hidden",
  ]
}

if (is_clang && !is_nacl) {
  _native_compiler_configs += [
    "//build/config/clang:extra_warnings",
  ]
}

# Debug/release-related defines.
if (is_debug) {
  _native_compiler_configs += [ "//build/config:debug" ]
} else {
  _native_compiler_configs += [ "//build/config:release" ]
}

if (is_win) {
  # Many targets remove these configs, so they are not contained within
  # //build/config:executable_config for easy removal.
  _windows_linker_configs = [
    "//build/config/win:default_incremental_linking",

    # Default to console-mode apps. Most of our targets are tests and such
    # that shouldn't use the windows subsystem.
    "//build/config/win:console",
  ]
}

# Executable defaults.
_executable_configs = _native_compiler_configs + [
                        "//build/config:default_libs",
                        "//build/config:executable_config",
                      ]
if (is_win) {
  _executable_configs += _windows_linker_configs
}
set_defaults("executable") {
  configs = _executable_configs
}

# Static library defaults.
set_defaults("static_library") {
  configs = _native_compiler_configs
}

# Shared library and loadable module defaults (also for components in component
# mode).
_shared_library_configs = _native_compiler_configs + [
                            "//build/config:default_libs",
                            "//build/config:shared_library_config",
                          ]
if (is_win) {
  _shared_library_configs += _windows_linker_configs
}
set_defaults("shared_library") {
  configs = _shared_library_configs
}
set_defaults("loadable_module") {
  configs = _shared_library_configs
}
if (is_component_build) {
  set_defaults("component") {
    configs = _shared_library_configs
  }
}

# Source set defaults (also for components in non-component mode).
set_defaults("source_set") {
  configs = _native_compiler_configs
}
if (!is_component_build) {
  set_defaults("component") {
    configs = _native_compiler_configs
  }
}

# Test defaults.
set_defaults("test") {
  if (is_android) {
    configs = _shared_library_configs
  } else {
    configs = _executable_configs
  }
}

# ==============================================================================
# COMPONENT SETUP
# ==============================================================================

# Defines a component, which equates to a shared_library when
# is_component_build == true and a source_set / static_library otherwise.
#
# Arguments are the same as a normal library with this addition:
#   component_never_use_source_set: Whether to use static_library instead of
#       source_set for non-component builds. Some targets (e.g. //base) should
#       use static_library rather than source_set to avoid linking unused object
#       files.
template("component") {
  _never_use_source_set = defined(invoker.component_never_use_source_set) &&
                          invoker.component_never_use_source_set
  assert(_never_use_source_set || true)  # Mark as used.
  if (is_component_build) {
    _component_mode = "shared_library"
  } else if (_never_use_source_set) {
    _component_mode = "static_library"
  } else {
    _component_mode = "source_set"
  }
  target(_component_mode, target_name) {
    forward_variables_from(invoker, "*")
  }
}

# XXX(chrisdickinson): Creating these dummy variables for V8's purposes.
is_msan = false
using_sanitizer = false
